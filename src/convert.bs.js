// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Shape = require("./shape.bs.js");
var Trait = require("./trait.bs.js");
var Generate = require("./generate.bs.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Belt_Option = require("rescript/lib/js/belt_Option.js");
var Caml_option = require("rescript/lib/js/caml_option.js");
var Dependencies = require("./dependencies.bs.js");
var Caml_exceptions = require("rescript/lib/js/caml_exceptions.js");

function optionalServiceName(optShape) {
  if (optShape !== undefined) {
    return optShape.name;
  }
  
}

function findServiceShape(shapes) {
  return Caml_option.undefined_to_opt(shapes.find(function (param) {
                  return Shape.isServiceShape(param.descriptor);
                }));
}

function getServiceDetails(serviceShapeOpt) {
  return Belt_Option.flatMap(serviceShapeOpt, (function (param) {
                var descriptor = param.descriptor;
                if (typeof descriptor === "number") {
                  return ;
                }
                if (descriptor.TAG !== /* ServiceShape */4) {
                  return ;
                }
                var match = Trait.findTrait(descriptor._0.traits, Trait.isAwsApiServiceTrait);
                if (match !== undefined && !(typeof match === "number" || match.TAG !== /* ServiceTrait */3)) {
                  return match._0;
                }
                
              }));
}

function kebabCaseToTitleCase(str) {
  return Belt_Array.joinWith(Belt_Array.map(str.split("-"), (function (part) {
                    return part.slice(0, 1).toUpperCase() + part.slice(1);
                  })), "", (function (x) {
                return x;
              }));
}

var UnexpectedStructure = /* @__PURE__ */Caml_exceptions.create("Convert.UnexpectedStructure");

function findOperationalStructure(structures, input) {
  if (input === undefined) {
    return /* OperationStructureNone */0;
  }
  var structure = structures.find(function (structure) {
        return structure.name === input;
      });
  if (structure === undefined) {
    return {
            TAG: /* OperationStructureRef */1,
            _0: input
          };
  }
  var details = structure.descriptor;
  if (typeof details === "number") {
    throw {
          RE_EXN_ID: UnexpectedStructure,
          _1: "expected structure type for " + input,
          Error: new Error()
        };
  }
  if (details.TAG === /* StructureShape */2) {
    return {
            TAG: /* OperationStructure */0,
            _0: details._0
          };
  }
  throw {
        RE_EXN_ID: UnexpectedStructure,
        _1: "expected structure type for " + input,
        Error: new Error()
      };
}

function convert(parsed) {
  if (parsed.TAG !== /* Ok */0) {
    return {
            TAG: /* Error */1,
            _0: "Unknown conversion error: " + parsed._0
          };
  }
  var shapesWithTargets = Belt_Array.map(parsed._0, (function (param) {
          var descriptor = param.descriptor;
          return {
                  name: param.name,
                  descriptor: descriptor,
                  targets: Dependencies.getTargets(descriptor),
                  recursWith: undefined
                };
        }));
  var shapesWithTargets$1 = Dependencies.order(shapesWithTargets);
  var match = Belt_Array.partition(shapesWithTargets$1, (function (param) {
          var tmp = param.descriptor;
          if (typeof tmp === "number" || tmp.TAG !== /* OperationShape */1) {
            return false;
          } else {
            return true;
          }
        }));
  var match$1 = Belt_Array.partition(match[1], (function (param) {
          return Belt_Option.isSome(param.recursWith);
        }));
  var allStructures = match$1[1];
  var operations = Belt_Array.keepMap(match[0], (function (shape) {
          var details = shape.descriptor;
          if (typeof details === "number" || details.TAG !== /* OperationShape */1) {
            return ;
          } else {
            return [
                    shape.name,
                    details._0,
                    shape.targets
                  ];
          }
        }));
  var operationDependencies = Belt_Array.concatMany(Belt_Array.map(operations, (function (param) {
              return param[2];
            })));
  var match$2 = Belt_Array.partition(allStructures, (function (structure) {
          var name = structure.name;
          var tmp = structure.descriptor;
          if (typeof tmp === "number" || !(tmp.TAG === /* StructureShape */2 && operationDependencies.includes(name))) {
            return false;
          } else {
            return !Belt_Array.some(allStructures, (function (param) {
                          return Belt_Array.some(param.targets, (function (target) {
                                        return target === name;
                                      }));
                        }));
          }
        }));
  var remainingStructures = match$2[1];
  var operationStructures = match$2[0];
  var operationModuleParts = Belt_Array.map(operations, (function (param) {
          var details = param[1];
          var inputString = Belt_Option.getWithDefault(details.input, "");
          var outputString = Belt_Option.getWithDefault(details.output, "");
          var structures = Belt_Array.keep(operationStructures, (function (structure) {
                  if (structure.name === inputString) {
                    return true;
                  } else {
                    return structure.name === outputString;
                  }
                }));
          return [
                  param[0],
                  details,
                  structures
                ];
        }));
  var service = findServiceShape(remainingStructures);
  var serviceDetails = getServiceDetails(service);
  if (serviceDetails === undefined) {
    return {
            TAG: /* Error */1,
            _0: "no service definition in file"
          };
  }
  var packagingName = serviceDetails.arnNamespace;
  var moduleName = serviceDetails.cloudFormationName.replace(" ", "");
  var operationSnippets = Belt_Array.map(operationModuleParts, (function (param) {
          var structures = param[2];
          var details = param[1];
          var inputOperationStructure = findOperationalStructure(structures, details.input);
          var outputOperationStructure = findOperationalStructure(structures, details.output);
          return Generate.generateOperationModule(packagingName, [
                      param[0],
                      inputOperationStructure,
                      outputOperationStructure
                    ]);
        }));
  var codeSnippets = Belt_Array.map(remainingStructures, (function (shape) {
          return Generate.generateTypeBlock(packagingName, {
                      name: shape.name,
                      descriptor: shape.descriptor
                    });
        }));
  return {
          TAG: /* Ok */0,
          _0: {
            moduleName: moduleName,
            code: Belt_Array.joinWith(Belt_Array.concat(codeSnippets, operationSnippets), "\n", (function (x) {
                    return x;
                  }))
          }
        };
}

exports.optionalServiceName = optionalServiceName;
exports.findServiceShape = findServiceShape;
exports.getServiceDetails = getServiceDetails;
exports.kebabCaseToTitleCase = kebabCaseToTitleCase;
exports.UnexpectedStructure = UnexpectedStructure;
exports.findOperationalStructure = findOperationalStructure;
exports.convert = convert;
/* No side effect */
