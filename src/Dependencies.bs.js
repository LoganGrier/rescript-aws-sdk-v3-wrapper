// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Caml = require("rescript/lib/js/caml.js");
var Belt_Id = require("rescript/lib/js/belt_Id.js");
var Belt_Set = require("rescript/lib/js/belt_Set.js");
var Caml_obj = require("rescript/lib/js/caml_obj.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Belt_Option = require("rescript/lib/js/belt_Option.js");
var Caml_exceptions = require("rescript/lib/js/caml_exceptions.js");

function cmp(v1, v2) {
  return Caml.caml_string_compare(v1.name, v2.name);
}

var ShapeWithTargetComparator = Belt_Id.MakeComparable({
      cmp: cmp
    });

var smithyImplicitShapes = [
  {
    name: "smithy.api#String",
    descriptor: {
      TAG: /* StringShape */7,
      _0: {
        traits: undefined
      }
    },
    targets: [],
    recursWith: undefined
  },
  {
    name: "smithy.api#Boolean",
    descriptor: {
      TAG: /* BooleanShape */5,
      _0: {
        traits: undefined
      }
    },
    targets: [],
    recursWith: undefined
  },
  {
    name: "smithy.api#Integer",
    descriptor: {
      TAG: /* IntegerShape */6,
      _0: {
        traits: undefined
      }
    },
    targets: [],
    recursWith: undefined
  },
  {
    name: "smithy.api#Timestamp",
    descriptor: {
      TAG: /* TimestampShape */9,
      _0: {
        traits: undefined
      }
    },
    targets: [],
    recursWith: undefined
  },
  {
    name: "smithy.api#Long",
    descriptor: {
      TAG: /* LongShape */10,
      _0: {
        traits: undefined
      }
    },
    targets: [],
    recursWith: undefined
  }
];

function getTargets(descriptor) {
  if (typeof descriptor === "number") {
    return [];
  }
  switch (descriptor.TAG | 0) {
    case /* ListShape */0 :
        return [descriptor._0.target];
    case /* OperationShape */1 :
        var details = descriptor._0;
        return Belt_Array.concatMany([
                    Belt_Option.getWithDefault(Belt_Option.map(details.input, (function (extracted) {
                                return [extracted];
                              })), []),
                    Belt_Option.getWithDefault(Belt_Option.map(details.output, (function (extracted) {
                                return [extracted];
                              })), []),
                    Belt_Option.getWithDefault(Belt_Option.map(details.errors, (function (extracted) {
                                return extracted;
                              })), [])
                  ]);
    case /* StructureShape */2 :
        return descriptor._0.members.map(function (member) {
                    return member.target;
                  });
    case /* UnionShape */3 :
        return descriptor._0.members.map(function (member) {
                    return member.target;
                  });
    case /* ServiceShape */4 :
        return Belt_Option.getWithDefault(descriptor._0.operations, []);
    case /* MapShape */8 :
        var match = descriptor._0;
        return [
                match.mapKey.target,
                match.mapValue.target
              ];
    case /* SetShape */13 :
        return [descriptor._0.target];
    default:
      return [];
  }
}

function getShapeTargets(shapes) {
  return Belt_Array.map(shapes, (function (shape) {
                return [
                        shape,
                        getTargets(shape.descriptor)
                      ];
              }));
}

var CycleError = /* @__PURE__ */Caml_exceptions.create("Dependencies-AwsSdkV3.CycleError");

function containsAll(within, targets) {
  if (targets.length === 0) {
    return true;
  } else {
    return Belt_Array.every(targets, (function (target) {
                  return Belt_Array.some(within, (function (item) {
                                if (item.name === target) {
                                  return true;
                                } else {
                                  return Belt_Option.mapWithDefault(item.recursWith, false, (function (recursiveItems) {
                                                return Belt_Array.some(recursiveItems, (function (recursiveItem) {
                                                              return recursiveItem.name === target;
                                                            }));
                                              }));
                                }
                              }));
                }));
  }
}

function hasTarget(target, candidates) {
  return Belt_Array.some(candidates, (function (candidate) {
                return Belt_Array.some(candidate.targets, (function (candidateTarget) {
                              return candidateTarget === target;
                            }));
              }));
}

function filterOut(l, x) {
  return Belt_Array.keep(l, (function (i) {
                return Caml_obj.caml_notequal(i, x);
              }));
}

function getShapeWithTargetNames(s) {
  return Belt_Array.map(s, (function (param) {
                return param.name;
              }));
}

function findCycle(chain, remaining) {
  var last = Belt_Array.get(chain, chain.length - 1 | 0);
  if (last === undefined) {
    return ;
  }
  var targetsInChain = Belt_Array.keepMap(last.targets, (function (target) {
          return Belt_Array.getIndexBy(chain, (function (shape) {
                        return shape.name === target;
                      }));
        }));
  if (targetsInChain.length !== 0) {
    return Belt_Array.map(targetsInChain, (function (index) {
                  return Belt_Array.sliceToEnd(chain, index);
                }));
  }
  var follow = Belt_Array.keep(remaining, (function (shape) {
          return Belt_Array.some(last.targets, (function (target) {
                        return shape.name === target;
                      }));
        }));
  var cycles = Belt_Array.keepMap(follow, (function (shape) {
          var chain$1 = Belt_Array.concat(chain, [shape]);
          var remaining$1 = filterOut(remaining, shape);
          return findCycle(chain$1, remaining$1);
        }));
  if (cycles.length !== 0) {
    return Belt_Array.concatMany(cycles);
  }
  
}

function findCycles(shapes) {
  return Belt_Array.concatMany(Belt_Array.keepMap(shapes, (function (shape) {
                    var otherShapes = filterOut(shapes, shape);
                    return findCycle([shape], otherShapes);
                  })));
}

function isSubsetOf(target, test) {
  var targetSet = Belt_Set.fromArray(target, ShapeWithTargetComparator);
  var testSet = Belt_Set.fromArray(test, ShapeWithTargetComparator);
  return Belt_Set.isEmpty(Belt_Set.diff(testSet, targetSet));
}

function order_(_remaining, _ordered) {
  while(true) {
    var ordered = _ordered;
    var remaining = _remaining;
    if (remaining.length === 0) {
      return ordered;
    }
    var match = Belt_Array.partition(remaining, (function(ordered){
        return function (param) {
          return containsAll(ordered, param.targets);
        }
        }(ordered)));
    var unfree = match[1];
    var free = match[0];
    if (free.length === 0) {
      var cycles = findCycles(unfree);
      if (cycles.length === 0) {
        throw {
              RE_EXN_ID: CycleError,
              _1: getShapeWithTargetNames(free),
              _2: getShapeWithTargetNames(unfree),
              Error: new Error()
            };
      }
      var recursive = Belt_Array.reduce(Belt_Array.concatMany(cycles), [], (function (acc, x) {
              if (Belt_Array.some(acc, (function (y) {
                        return Caml_obj.caml_equal(x, y);
                      }))) {
                return acc;
              } else {
                return Belt_Array.concat(acc, [x]);
              }
            }));
      var firstItem = Belt_Array.get(recursive, 0);
      var recursiveItem = Belt_Option.mapWithDefault(firstItem, [], (function(recursive){
          return function (item) {
            return [{
                      name: item.name,
                      descriptor: item.descriptor,
                      targets: item.targets,
                      recursWith: Belt_Array.sliceToEnd(recursive, 1)
                    }];
          }
          }(recursive)));
      var unfree$1 = Belt_Array.keep(unfree, (function(recursive){
          return function (unfreeItem) {
            return !Belt_Array.some(recursive, (function (recursiveItem) {
                          return recursiveItem === unfreeItem;
                        }));
          }
          }(recursive)));
      var ordered$1 = Belt_Array.concatMany([
            ordered,
            free,
            recursiveItem
          ]);
      _ordered = ordered$1;
      _remaining = unfree$1;
      continue ;
    }
    var ordered$2 = Belt_Array.concat(ordered, free);
    _ordered = ordered$2;
    _remaining = unfree;
    continue ;
  };
}

function order(shapesWithTargets) {
  return order_(shapesWithTargets, smithyImplicitShapes);
}

exports.ShapeWithTargetComparator = ShapeWithTargetComparator;
exports.smithyImplicitShapes = smithyImplicitShapes;
exports.getTargets = getTargets;
exports.getShapeTargets = getShapeTargets;
exports.CycleError = CycleError;
exports.containsAll = containsAll;
exports.hasTarget = hasTarget;
exports.filterOut = filterOut;
exports.getShapeWithTargetNames = getShapeWithTargetNames;
exports.findCycle = findCycle;
exports.findCycles = findCycles;
exports.isSubsetOf = isSubsetOf;
exports.order_ = order_;
exports.order = order;
/* ShapeWithTargetComparator Not a pure module */
